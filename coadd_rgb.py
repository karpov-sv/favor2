#!/usr/bin/env python

# Modified code to flatten images while co-adding

import os
import warnings

import tempfile
import shutil

import numpy as np
from astropy import log
from astropy.io import fits

def make_rgb_cube(files, output, north=False, system=None, equinox=None, common=True):
    '''
    Make an RGB data cube from a list of three FITS images.

    This method can read in three FITS files with different
    projections/sizes/resolutions and uses Montage to reproject
    them all to the same projection.

    Two files are produced by this function. The first is a three-dimensional
    FITS cube with a filename give by `output`, where the third dimension
    contains the different channels. The second is a two-dimensional FITS
    image with a filename given by `output` with a `_2d` suffix. This file
    contains the mean of the different channels, and is required as input to
    FITSFigure if show_rgb is subsequently used to show a color image
    generated from the FITS cube (to provide the correct WCS information to
    FITSFigure).

    Parameters
    ----------

    files : tuple or list
       A list of the filenames of three FITS filename to reproject.
       The order is red, green, blue.

    output : str
       The filename of the output RGB FITS cube.

    north : bool, optional
       By default, the FITS header generated by Montage represents the
       best fit to the images, often resulting in a slight rotation. If
       you want north to be straight up in your final mosaic, you should
       use this option.

    system : str, optional
       Specifies the system for the header (default is EQUJ).
       Possible values are: EQUJ EQUB ECLJ ECLB GAL SGAL

    equinox : str, optional
       If a coordinate system is specified, the equinox can also be given
       in the form YYYY. Default is J2000.
    '''

    # Check whether the Python montage module is installed. The Python module
    # checks itself whether the Montage command-line tools are available, and
    # if they are not then importing the Python module will fail.
    try:
        import montage_wrapper as montage
    except ImportError:
        raise Exception("Both the Montage command-line tools and the"
                        " montage-wrapper Python module are required"
                        " for this function")

    # Check that input files exist
    for f in files:
        if f and not os.path.exists(f):
            raise Exception("File does not exist : " + f)

    # Create work directory
    work_dir = tempfile.mkdtemp()
    
    raw_dir = '%s/raw' % work_dir
    final_dir = '%s/final' % work_dir
    flat_dir = '%s/flat' % work_dir

    images_raw_tbl = '%s/images_raw.tbl' % work_dir
    images_final_tbl = '%s/images_final.tbl' % work_dir
    header_hdr = '%s/header.hdr' % work_dir

    # Create raw and final directory in work directory
    os.mkdir(raw_dir)
    os.mkdir(final_dir)
    os.mkdir(flat_dir)

    # Create symbolic links to input files
    for i, f in enumerate(files):
        if f:
            os.symlink(os.path.abspath(f), '%s/image_%i.fits' % (raw_dir, i))

    # List files and create optimal header
    montage.mImgtbl(raw_dir, images_raw_tbl, corners=True)
    montage.mMakeHdr(images_raw_tbl, header_hdr, north_aligned=north, system=system, equinox=equinox)

    # Read header in with astropy.io.fits
    header = fits.Header.fromtextfile(header_hdr)

    # Find image dimensions
    nx = int(header['NAXIS1'])
    ny = int(header['NAXIS2'])

    # Loop through files
    for i in range(len(files)):
        # Reproject channel to optimal header
        print files[i]
        if files[i]:
            montage.reproject('%s/image_%i.fits' % (raw_dir, i),
                              '%s/image_%i.fits' % (final_dir, i),
                              header=header_hdr, exact_size=True, bitpix=-32)

    montage.mImgtbl(final_dir, images_final_tbl, corners=True)
    montage.mFlattenExec(images_final_tbl, flat_dir, no_area=True, debug=True)

    mask = None

    for i in range(len(files)):
        if files[i]:
            image = fits.getdata('%s/image_%i.fits' % (flat_dir, i))

            if mask is None:
                mask = np.isfinite(image)
            else:
                mask = mask & np.isfinite(image)

    y,x = np.mgrid[0:mask.shape[0],0:mask.shape[1]]

    x1, x2, y1, y2 = min(x[mask]), max(x[mask]), min(y[mask]), max(y[mask])
                
    # Generate emtpy datacube
    image_cube = np.zeros((len(files), y2-y1, x2-x1), dtype=np.float32)

    for i in range(len(files)):
        # Read in and add to datacube
        #image_cube[i, :, :] = fits.getdata('%s/image_%i.fits' % (final_dir, i))
        if files[i]:
            image = fits.getdata('%s/image_%i.fits' % (flat_dir, i))
            image = image[y1:y2, x1:x2]
            image_cube[i, :, :] = image

    # Write out final cube
    fits.writeto(output, image_cube, header, clobber=True)

    # Write out collapsed version of cube
    fits.writeto(output.replace('.fits', '_2d.fits'), \
                   np.mean(image_cube, axis=0), header, clobber=True)

    # Remove work directory
    shutil.rmtree(work_dir)
    #print work_dir
    
